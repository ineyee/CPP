## 一、类、对象、成员变量、成员函数

#### 1、类、对象、成员变量、成员函数

C++里可以用struct关键字或class关键字定义一个类，比如：

```c++
#include <iostream>
using namespace std;

// 用struct关键字定义一个Person类
struct Person {
    // 成员变量
    int m_age;

    // 成员函数
    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

int main() {
    // 创建一个person对象
    Person person;
    person.m_age = 10;
    person.run(); // 10 run()
    
    return 0;
}
```

```c++
#include <iostream>
using namespace std;

// 用class关键字定义一个Person类
class Person {
public:
    // 成员变量
    int m_age;

    // 成员函数
    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

int main() {
    // 创建一个person对象
    Person person;
    person.m_age = 10;
    person.run(); // 10 run()
    
    return 0;
}
```

那用struct关键字和class关键字定义一个类有什么区别呢？

* 它俩唯一的区别就是用struct关键字定义的类默认的成员访问权限是public，而用class关键字定义的类默认的成员访问权限是private

那既然已经有class关键字了，为啥还要有struct关键字呢？

* 这主要是因为C里是用结构体来模拟类的效果的，所以为了向下兼容，也为了能让C开发者平滑过渡，C++里才保留了struct关键字，但在C++里我们不必把struct关键字当作结构体来看待，直接跟class关键字一样当作类来看待就可以了

推荐使用class关键字定义一个类，而非struct关键字定义一个类，因为class关键字毕竟是C++专门推出的语法。

#### 2、类存储在哪里、类占用多大的内存

我们可以用struct关键字来定义结构体类型、enum关键字来定义枚举类型，这些类型本身其实就是一坨代码，是存储在代码区的，结构体类型、枚举类型创建出来的变量才存储在栈区、堆区、静态全局区。

```c++
struct grade {
    char rank;
    int score;
};

enum season {
    SPRING = 10,
    SUMMER,
    AUTUMN = 20,
    WINTER,
};
```

用class关键字定义的类无非也是一种数据类型，也就是说类本身其实也是一坨代码，也是存储在代码区的，类创建出来的对象才存储在栈区、堆区、静态全局区。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};
```

类占用多大的内存主要取决于类的代码量，没有一个固定的值，也没有一个固定的计算方法。

#### 3、对象存储在哪里、对象占用多大的内存

其它语言里对象只能存在在堆区，而C++里对象可以存在在栈区、堆区、静态全局区。下面的代码中我们创建了一个栈区的person对象，它的内存布局大概如下：

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

int main() {
    Person person;
  	// 对象访问成员变量和成员函数用.
    person.m_age = 10;
    person.run(); // 10 run()

    return 0;
}
```

![image-20230515150518885](image-20230515150518885.png)

下面的代码中我们创建了一个堆区的person对象，它的内存布局大概如下：

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

int main() {
    Person *person = new Person();
  	// 对象指针访问成员变量和成员函数用->
    person->m_age = 10;
    person->run(); // 10 run()
    delete person;

    return 0;
}
```

![image-20230515150431887](image-20230515150431887.png)

下面的代码中我们创建了一个静态全局区的person对象，它的内存布局大概如下：

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

Person person;

int main() {
    // 对象访问成员变量和成员函数用.
    person.m_age = 10;
    person.run(); // 10 run()

    return 0;
}
```

![image-20230515150618405](image-20230515150618405.png)

C++里对象的内存大小，就按结构体变量的内存大小那样去分析就是对的。需要注意的是对象的内存大小只跟成员变量有关，只有成员变量的值才存储在对象内部，成员函数是存储在代码区的，所以成员函数不占用对象的内存。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

int main() {
    Person person;
  	// person对象m_age的值为10
    person.m_age = 10;
  	// person对象调用run成员函数
    person.run(); // 10 run()
    cout << sizeof(person) << endl; // 4
    
    Person person1;
    // person1对象m_age的值为20
    person1.m_age = 20;
    // person1对象调用run成员函数
    person1.run(); // 20 run()
    cout << sizeof(person1) << endl; // 4
    
    return 0;
}
```

#### 3、成员变量存储在哪里

成员变量的值存储在对象内部，这也很好理解，不同对象的成员变量有不同的值，所以成员变量的值必须要存储在各自对象的内部，否则就没办法区分某个值到底是哪个对象的。

#### 4、成员函数存储在哪里

成员函数存储在代码区，这也很好理解，对于同一个成员函数所有的对象调用的都是同一段代码，所以成员函数只需要在代码区存一份就够了，没必要每个对象内部都存一份浪费内存。

#### 5、this指针

上面我们说到“成员变量的值存储在对象内部，成员函数存储在代码区”，也就是说下面的代码中10存储在person对象内部、20存储在person1对象内部，run成员函数存储在代码区只有一份，那么问题来了，既然run成员函数不存储在person对象和person1对象内部，那run成员函数执行体里是怎么知道person对象调用的时候就打印10、person1对象调用的时候就打印20的呢，也就是说代码区的run到底是怎么访问到person、person1这两块栈区的内存的呢？

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

int main() {
    Person person;
    person.m_age = 10;
    person.run(); // 10 run()
    
    Person person1;
    person1.m_age = 20;
    person1.run(); // 20 run()
    
    return 0;
}
```

如果让我们自己实现，也很简单，那就是把调用run成员函数的那个对象作为参数传递给run成员函数——当然因为对象占用的内存可能比较大，所以建议通过指针的方式传递，避免过多地消耗栈内存——这样run成员函数执行体里就能知道是打印person对象的10还是打印person1对象的20了，如下：

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run(Person *my_this) {
        cout << my_this->m_age << " " << "run()" << endl;
    }
};

int main() {
    Person person;
    person.m_age = 10;
    person.run(&person); // 10 run()
    
    Person person1;
    person1.m_age = 20;
    person1.run(&person1); // 20 run()

    return 0;
}
```

其实编译器就是这么做的，编译器已经帮我们做好了这件事，它会为每一个成员函数都添加一个隐式参数——this指针，外界某个对象通过点语法调用成员函数这种高级语言里的写法，在编译的时候编译器就是把外界这个对象的内存地址传递给成员函数的this指针，于是this指针就指向了成员函数的调用者，因此我们就可以在成员函数执行体里通过this指针来访问某个具体对象的成员变量、成员函数了，当然因为this是个指针，所以只能通过this->的方式来访问，而不能通过this.的方式来访问，当然我们也可以省略this直接访问，所有的面向对象语言里对象调用成员函数都是这么设计的。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run() {
        cout << this->m_age << " " << "run()" << endl;
    }
};

int main() {
    Person person;
    person.m_age = 10;
    person.run(); // 10 run()，可以理解为run(&person);
    
    Person person1;
    person1.m_age = 20;
    person1.run(); // 20 run()，可以理解为run(&person1);

    return 0;
}
```

#### 6、成员变量和成员函数的访问权限

成员变量和成员函数的访问权限一共有3个级别，从高到低依次是：

* public：在当前类 + 子类 + 当前类和子类以外项目里的任何地方都能访问（用struct关键字定义一个类默认）

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person {
  public:
      int m_age;
  
      void run() {
          // 在当前类里能访问
          cout << m_age << " " << "run()" << endl;
      }
  };
  
  // 继承方式一共也有3种：public、protected、private，用class关键字定义一个类默认的继承方式为private
  // 这个就不展开说了，没多大意义，实际开发中我们都用public继承就可以了
  class Student : public Person {
  public:
      int m_no;
      
      void study() {
          // 在子类里能访问
          cout << m_age << " " << "study()" << endl;
      }
  };
  
  int main() {
      Person *person = new Person();
      // 在当前类和子类以外项目里的任何地方都能访问
      cout << person->m_age << endl;
      person->run();
      delete person;
      
      return 0;
  }
  ```

* protected：在当前类 + 子类里能访问

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person {
  protected:
      int m_age;
  
      void run() {
          // 在当前类里能访问
          cout << m_age << " " << "run()" << endl;
      }
  };
  
  class Student : public Person {
  public:
      int m_no;
      
      void study() {
          // 在子类里能访问
          cout << m_age << " " << "study()" << endl;
      }
  };
  
  int main() {
      Person *person = new Person();
      // 无法在当前类和子类以外项目里的任何地方都能访问
  //    cout << person->m_age << endl;
  //    person->run();
      delete person;
      
      return 0;
  }
  ```

* private：仅在当前类里能访问（用class关键字定义一个类默认）

  ```c++
  #include <iostream>
  using namespace std;
  
  class Person {
  private:
      int m_age;
  
      void run() {
          // 在当前类里能访问
          cout << m_age << " " << "run()" << endl;
      }
  };
  
  class Student : public Person {
  public:
      int m_no;
      
      void study() {
          // 无法在子类里能访问
  //        cout << m_age << " " << "study()" << endl;
      }
  };
  
  int main() {
      Person *person = new Person();
      // 无法在当前类和子类以外项目里的任何地方都能访问
  //    cout << person->m_age << endl;
  //    person->run();
      delete person;
      
      return 0;
  }
  ```

#### 7、静态成员变量

静态成员变量是指用static修饰的成员变量，可以用“类名::静态成员变量”的方式来访问。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    // 声明一个静态成员变量
    static int sm_age;
};

// 静态成员变量在使用前必须初始化，初始化也有几个要求：
// 1、必须在类外面、在函数外面初始化
// 2、初始化时不能再写static，但一定要写上类名
// 3、如果类的声明和实现分离，则声明操作写在.h文件里、初始化操作写在.cpp文件里
int Person::sm_age = 18;

int main() {
    // 赋值
    Person::sm_age = 24;
    // 读取
    cout << Person::sm_age << endl;
    
    return 0;
}
```

我们知道一个类里普通成员变量的值是存储在每个对象内部的，有多份，而一个类里静态成员变量的值是存储在静态全局区的，只有一份，类似于普通静态变量，跟普通的静态全局变量不同就是静态成员变量只有通过当前类才能访问，并且静态全局变量还可以设置public、protected、private这种访问权限，这两组不就像是给普通静态变量加了些访问约束吗？你可能会问这两组访问约束是怎么实现的？编译器又是怎么找到存储在静态全局区的静态成员变量的呢？

这其实也很简单，我们知道编译器在编译到访问普通静态变量的代码时会直接翻译成对这个普通静态变量所对应内存访问的汇编，如“static int sg_age = 10;”，编译器会直接翻译成类似“mov 0x100 #10”这样的汇编，那只要编译器在编译到访问静态成员变量的代码时不是无条件地翻译成汇编，而是先判断一下我们在高级语言里是否用了“类名::静态成员变量”这样固定的语法来访问，如果用了那就也翻译成“mov 0x100 #10”这样的汇编，如果没用那就编译报错不让你访问，这不就实现了访问约束了嘛。也就是说普通成员变量、静态成员变量、普通静态变量......只要你是变量，那它们的本质就绝对是一样的——那就是对应着一块内存，对变量的访问就是对那块内存的访问——这在汇编眼里无非就是mov等指令嘛，而在高级语言里不同变量拥有不同的访问权限则完全是通过编译器搞得鬼——强制你只能用某种方式访问。找嘛就是根据高级语言里固定的语法直接翻译为函数的地址就找到了、不存在什么流程。

#### 8、静态成员函数

静态成员函数是指用static修饰的成员函数，可以用“类名::静态成员函数”的方式来访问。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    static int sm_age;
    int m_height;
    
    // 声明并实现一个静态成员函数
    static void run() {
        cout << "static Person::run()" << endl;

        cout << Person::sm_age << endl;
    };
    
    // 静态成员函数不能是虚函数，虚函数只能是非静态成员函数
//    virtual static void run() {
//        cout << "static Person::run()" << endl;
//    };
    
//    static void run() {
//        cout << "static Person::run()" << endl;
//
//        // 静态成员函数内部不能非静态成员函数、非静态成员变量，只能访问静态成员函数、静态成员变量
//        cout << m_height << endl;
//    };
  
//    static void run() {
//        cout << "static Person::run()" << endl;
//
//        // 静态成员函数内部不能用this指针，C++里this指针只指向对象，不指向类
  				// 也就是说静态成员函数没有隐式参数this指针，这也很好理解，因为this指针是用来调用成员变量和成员函数的，而静态成员函数内部不能非静态成员，只能访问静态成员，而访问静态成员的语法已经有了类名::静态成员，那还要this指针干啥，没必要了啊
//        cout << this->sm_age << endl;
//    };
    
    // 当声明和实现分离时，static只能写在声明阶段，实现阶段不能不能写static
 		
  	// 构造函数和析构函数不能搞成静态的，构造函数和析构函数不是成员函数嘛，而静态不静态是针对成员函数的
};

int Person::sm_age = 18;

int main() {
    Person::run();
    
    return 0;
}
```

静态成员函数存储在代码区，也是只有一份，跟普通函数的区别无非也是只能通过“类名::静态成员函数”来访问这个函数，这种访问权限没什么好说的，无非就是编译器做的一层限制，即编译器一见到“类名::静态成员函数”这样的代码就直接翻译成了“bl 某个静态成员函数的内存地址”这样的汇编，而见到其它访问静态成员函数的代码就一律编译报错，所以也没什么大不了的。编译器见到普通函数的调用不就是一律翻译成“bl 函数的地址”嘛，少了编译报错的一些限制而已。但无论是什么函数的调用，只要能调用，那本质必然是bl 函数地址。

#### 9、静态成员的经典应用场景：单例模式

```c++
class Rocket {
private:
    // 第一步：构造方法私有化（保证单例的唯一型)
    // 目的是为了禁止外界直接调用构造方法创建单例对象，而只能通过我们提供的方法来创建单例对象
    Rocket() {}
      // 析构函数私有化，防止外界主动调用delete
    ~Rocket() {}
    // 拷贝构造函数也要私有化，避免外界通过拷贝的方式来创建对象
    Rocket(const Rocket &rocket) {}
    
    // 第二步：定义一个静态的（保证单例的不死性）单例对象属性、私有的（因为我们不希望外界直接访问这个单例对象，而是通过我们提供的方法访问）
    static Rocket *sm_rocket;
public:
    // 第三步：提供一个静态的（因为不需要创建单例对象就得能调用）、公开的（因为外界要使用）获取单例对象的方法给外界，返回单例对象
    static Rocket* sharedRocket() {
        // 这里要考虑线程安全问题
        if (sm_rocket == NULL) {
            sm_rocket = new Rocket();
        }
        
        return sm_rocket;
    }
    
    static void deleteRocket() {
        // 这里要考虑线程安全问题
        if (sm_rocket != NULL) {
            delete sm_rocket;
            sm_rocket = NULL;
        }
    }
};
Rocket *Rocket::sm_rocket = NULL;
```

#### 10、构造函数和析构函数

###### 10.1 构造函数

对象创建的时候会自动调用它的构造函数，一般用来完成对象的初始化工作——如为成员变量赋初值等。C++里构造函数的特点是：

* 函数名与类名相同，可以有参数也可以没有参数，无返回值（void也不能写），支持重载——即可以有多个构造函数
* 编译器不会轻易为类自动生成构造函数，只有少数特殊情况才会自动生成，比如我们在声明成员变量的时候就完成了成员变量的初始化，编译器才会为类自动生成一个无参构造函数，像下面这样（这种是直接初始化成员变量 + 使用无参构造方法创建对象的方式，没有问题，只要保证成员变量初始化了就行，这相当于成员变量初始化的第一种方式）：

```c++
#include <iostream>
using namespace std;

class Person {
public:
    // 声明成员变量的时候就完成了成员变量的初始化
    int m_age = 0;
    int m_height = 60;
};

int main() {
    // 无参构造函数
    Person *person = new Person();
    cout << person->m_age << endl; // 0
    cout << person->m_height << endl; // 60
    delete person;
    
    return 0;
}

// 为什么要生成呢？
// 这是因为我们在 声明成员变量的时候就完成了成员变量的初始化，这个操作的本质其实就是在无参构造函数里赋值，也就是说上面的代码完全等价于
class Person {
public:
    int m_age;
    int m_height;
  
    // 无参构造函数
    Person() {
        m_age = 0;
        m_height = 60;
    }
};
```

* 如果我们在声明成员变量的时候没有完成成员变量的初始化，那我们就得自定义类的构造函数，自定义构造函数的核心宗旨是：类的构造函数必须得保证类的每个成员变量都能被初始化（一旦我们自定义了类的构造函数，编译器就不会自动为类生成构造函数了，一个也不会，我们就只能用我们自定义的构造函数来创建对象了），像下面这样（这种是不直接初始化成员变量 + 使用全能或无参构造方法创建对象的方式，也没有问题，只要保证成员变量初始化了就行，这相当于成员变量初始化的第二种方式）：

```c++
#include <iostream>
using namespace std;

class Person {
public:
    // 声明成员变量的时候没有完成成员变量的初始化
    int m_age;
    double m_height;
    
    // 全能构造函数
    Person(int age, double height) {
        m_age = age;
        m_height = height;
    }
    
    // 无参构造函数
    //
    // 调用一下全能构造函数
    Person() : Person(0, 60) {}
    
    // 部分参数构造函数
    //
    // 调用一下全能构造函数
    Person(int age) : Person(age, 60) {}
    
    // 部分参数构造函数
    //
    // 调用一下全能构造函数
    Person(double height) : Person(0, height) {}
    
    // 其它构造函数如果想调用全能构造函数，不能像下面这样写，因为这样写其实是在构造函数里创建了一个对象
//    Person() {
//        Person(0, 0);
//    }
//
//    Person(int age) {
//        Person(age, 60);
//    }
//
//    Person(double height) {
//        Person(0, height);
//    }
};

int main() {
    // 全能构造函数
    Person *person = new Person(18, 180);
    cout << person->m_age << endl; // 18
    cout << person->m_height << endl; // 180
    delete person;
    
    // 无参构造函数
    Person *person1 = new Person();
    cout << person1->m_age << endl; // 0
    cout << person1->m_height << endl; // 60
    delete person1;
    
    return 0;
}
```

###### 10.2 析构函数

对象销毁的时候会自动调用它的析构函数，一般用来完成对象的清理工作——如delete掉指向堆区的指针类型的成员变量等。C++里析构函数的特点是：

* 函数名与类名相同、前面有个~号，无参，无返回值（void也不能写），不支持重载——即有且只有一个析构函数，像下面这样：

```c++
#include <iostream>
using namespace std;

class Car {
public:
    double m_price;
    
    Car() {
        m_price = 30;
    }
};

class Person {
public:
    int m_age;
    int m_height;
    Car *m_car;
    
    Person() {
        m_age = 0;
        m_height = 60;
        // 因为是在对象内部申请的堆内存
        m_car = new Car();
    }
    
    ~Person() {
        // 所以最好在对象内部回收掉，不要让外界做多余的事
        delete m_car;
    }
};

int main() {
    Person *person = new Person();
    cout << person->m_age << endl; // 0
    cout << person->m_height << endl; // 60
    cout << person->m_car->m_price << endl; // 30
    delete person;
    
    return 0;
}
```

#### 11、成员变量的初始化

成员变量在未被初始化之前，它里面存储的值是以前使用过的垃圾值，因此成员变量在使用之前必须初始化，避免因为垃圾值带来未知的错误（尽管有些情况下编译器会自动帮我们初始化一个默认值，但并非所有的情况都如此，所以还是建议手动初始化）。关于成员变量的初始化，我们有三种方式：

* 第一种方式：声明成员变量的时候能直接初始化的就直接初始化掉

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age = 0;
    int m_height = 60;
};

int main() {
    Person *person = new Person();
    cout << person->m_age << endl; // 0
    cout << person->m_height << endl; // 60
    delete person;
    
    return 0;
}
```

* 第二种方式：如果第一阶段不方便初始化，那就自定义构造函数，因为外界创建对象肯定要调用我们自定义的构造函数，所以可以用外界传进来的值在构造函数里完成成员变量的初始化——这是全能构造函数，我们也可以定义无参构造函数直接在构造函数里完成成员变量的初始化，当然我们还可以定义其它部分参数构造函数，也可以给构造函数的参数赋默认值，但是需要注意构造函数重载时不要产生二义性

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;
    int m_height;
    
    Person(int age, int height) {
        m_age = age;
        m_height = height;
    }
    
    Person() {
        m_age = 0;
        m_height = 60;
    }
};

int main() {
    Person *person = new Person(18, 180);
    cout << person->m_age << endl; // 18
    cout << person->m_height << endl; // 180
    delete person;
    
    Person *person1 = new Person();
    cout << person1->m_age << endl; // 0
    cout << person1->m_height << endl; // 60
    delete person1;
    
    return 0;
}
```

但实际在使用这种方式的时候，我们更多地是使用初始化列表的方式来初始化成员变量，而非在构造函数执行体里初始化成员变量，因为像引用类型的成员变量、const成员变量必须在声明的时候就初始化，所以它们无法放在构造函数执行体里初始化，而必须放在初始化列表里，所以为了统一，我们会将所有成员变量的初始化都放在成员变量初始化列表里来初始化。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;
    const double &m_height;
    const int m_id;
    
    // height：为了外界能直接传一个数值进来，我们只能把它搞成const，因为只有const引用才可以接收数值
    // 这样因为只有const成员才能接收const成员，所以得把成员变量也搞成const
    Person(int age, const double &height, const int id)
    : m_age(age),
      m_height(height),
      m_id(id)
    {}
};

int main() {
    Person *person = new Person(18, 180, 140428);
    cout << person->m_age << endl; // 18
    cout << person->m_height << endl; // 180
    cout << person->m_id << endl; // 140428
    delete person;
    
    return 0;
}
```

当然我们也可以给某些成员变量赋默认值。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;
    const double &m_height;
    const int m_id;
    
    // height：为了外界能直接传一个数值进来，我们只能把它搞成const，因为只有const引用才可以接收数值
    // 这样因为只有const成员才能接收const成员，所以得把成员变量也搞成const
    Person(int age, const double &height, const int id = 140428)
    : m_age(age),
      m_height(height),
      m_id(id)
    {}
};

int main() {
    Person *person = new Person(18, 180, 140428);
    cout << person->m_age << endl; // 18
    cout << person->m_height << endl; // 180
    cout << person->m_id << endl; // 140428
    delete person;
    
    return 0;
}
```

* 第三种方式：如果第二阶段不方便初始化，那就只好late延迟初始化了，所谓延迟初始化是指我们暂时不初始化成员变量，直到它使用前再初始化，作为开发者我们一定要保证成员变量在使用之前被初始化掉，否则使用时可能会出错

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;
    int m_height;
};

int main() {
    Person *person = new Person();
    person->m_age = 18;
    person->m_height = 180;
    cout << person->m_age << endl; // 18
    cout << person->m_height << endl; // 180
    delete person;
    
    return 0;
}
```

C++里用得一般就是第二阶段。

#### 12、补充

###### 12.2 类的声明和实现分离

很多语言里没有类的声明和实现分离，C++里类的声明和实现分离是指类的声明放在头文件里——.h文件——主要包含类的声明、成员变量的声明、成员函数的声明、构造函数的声明、析构函数的声明等，类的实现放在源文件里——.cpp文件——主要包含成员函数的实现、构造函数的实现、析构函数的实现等。

```c++
// Person.h
#ifndef Person_h
#define Person_h

class Person {
public:
    int m_age;
    int m_height;
    
    void run();
    
    Person();
    ~Person();
};

#endif /* Person_h */
```

```c++
// Person.cpp
#include <iostream>
#include "Person.h"
using namespace std;

void Person::run() {
    cout << m_age << " " << "run()" << endl;
}

Person::Person() {
    m_age = 0;
    m_height = 60;
}

Person::~Person() {
    cout << "~Person()" << endl;
}
```
