## 一、类、对象、成员变量、成员函数

#### 1、类、对象、成员变量、成员函数

C++里可以用struct关键字或class关键字定义一个类，比如：

```c++
#include <iostream>
using namespace std;

// 用struct关键字定义一个Person类
struct Person {
    // 成员变量
    int m_age;

    // 成员函数
    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

int main() {
    // 创建一个person对象
    Person person;
    person.m_age = 10;
    person.run(); // 10 run()
    
    return 0;
}
```

```c++
#include <iostream>
using namespace std;

// 用class关键字定义一个Person类
class Person {
public:
    // 成员变量
    int m_age;

    // 成员函数
    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

int main() {
    // 创建一个person对象
    Person person;
    person.m_age = 10;
    person.run(); // 10 run()
    
    return 0;
}
```

那用struct关键字和class关键字定义一个类有什么区别呢？

* 它俩唯一的区别就是用struct关键字定义的类默认的成员访问权限是public，而用class关键字定义的类默认的成员访问权限是private

那既然已经有class关键字了，为啥还要有struct关键字呢？

* 这主要是因为C里是用结构体来模拟类的效果的，所以为了向下兼容，也为了C开发者能平滑过渡，C++里才保留了struct关键字，但在C++里我们不必把struct关键字当作结构体来看待，直接跟class关键字一样当作类来看待就可以了

推荐使用class关键字定义一个类，而非struct关键字定义一个类，因为class关键字毕竟是C++专门推出的语法。

#### 3、对象的内存大小、内存布局

C++里对象的内存大小，就按结构体变量的内存大小那样去分析就是对的。需要注意的是对象的内存大小只跟成员变量有关，只有成员变量的值才存储在对象内部，成员函数是存储在代码区的，因此成员函数不占用对象的内存，这也很好理解，不同对象的成员变量有不同的值，因此成员变量的值必须要存储在各自的对象内部，否则就没办法区分某个值到底是哪个对象的，而成员函数却只需要存一份就够了，不同的对象调用时只需要把对象传递给成员函数就可以了，没必要存多份浪费内存。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

int main() {
    Person person;
    person.m_age = 10;
    person.run(); // 10 run()
    cout << sizeof(person) << endl; // 4
    
    return 0;
}
```

其它语言里对象只能存在于堆区，而C++里对象可以存在于栈区、堆区、静态全局区。下面的代码中我们创建了一个栈区的person对象，它的内存布局大概如下：

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

int main() {
    Person person;
    person.m_age = 10;
    person.run(); // 10 run()

    return 0;
}
```

![image-20230515150518885](image-20230515150518885.png)

下面的代码中我们创建了一个堆区的person对象，它的内存布局大概如下：

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

int main() {
    Person *person = new Person();
    person->m_age = 10;
    person->run(); // 10 run()
    delete person;

    return 0;
}
```

![image-20230515150431887](image-20230515150431887.png)

下面的代码中我们创建了一个静态全局区的person对象，它的内存布局大概如下：

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

Person person;

int main() {
    person.m_age = 10;
    person.run(); // 10 run()

    return 0;
}
```

![image-20230515150618405](image-20230515150618405.png)

#### 4、this

上面我们说过“只有成员变量的值才存储在对象内部，成员函数是存储在代码区的，成员函数只有一份”，也就是说下面的代码中10存储在person对象内部、20存储在person1对象内部，既然run成员函数存储在代码区，只有一份，不存储在person对象和person1对象内部，person对象和person1对象都调用代码区的同一个run成员函数，那run成员函数执行体里是怎么知道是要打印person对象的10还是person1对象的20的呢？

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run() {
        cout << m_age << " " << "run()" << endl;
    }
};

int main() {
    Person person;
    person.m_age = 10;
    person.run(); // 10 run()
    
    Person person1;
    person1.m_age = 20;
    person1.run(); // 20 run()

    return 0;
}
```

要是让我们自己实现，也很简单，那就是把一个对象传递给run成员函数，当然因为一个对象占用的内存可能比较大，所以建议通过指针的方式传递，避免过多的消耗栈内存，这样run成员函数执行体里是怎么知道是要打印person对象的10还是person1对象的20，如下：

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run(Person *my_this) {
        cout << my_this->m_age << " " << "run()" << endl;
    }
};

int main() {
    Person person;
    person.m_age = 10;
    person.run(&person); // 10 run()
    
    Person person1;
    person1.m_age = 20;
    person1.run(&person1); // 20 run()

    return 0;
}
```

其实编译器就是这么做的，它会为每一个成员函数都添加一个隐式参数——this指针，外界某个对象通过点语法调用成员函数，在编译的时候编译器就会把外界这个对象的内存地址传递给成员函数的this指针，this指针就会指向成员函数的调用者，因此我们就可以在成员函数执行体内部通过this指针来访问具体的对象了，当然因为this是个指针，所以只能通过this->的方式来访问对象，而不能通过this.的方式来访问对象，当然我们可以省略this，面向对象语言基本都是这么设计的。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;

    void run() {
        cout << this->m_age << " " << "run()" << endl;
    }
};

int main() {
    Person person;
    person.m_age = 10;
    person.run(); // 10 run()
    
    Person person1;
    person1.m_age = 20;
    person1.run(); // 20 run()

    return 0;
}
```

