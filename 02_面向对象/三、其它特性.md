## 三、其它特性

#### 3、内存管理

内存管理是指堆内存的管理，因为只有对内存是由我们程序员自己控制的。

###### 3.1 C++里堆内存的开辟和释放

C++里堆内存的开辟和释放有两组方式：malloc和free、new和delete，推荐使用new和delete，因为毕竟是C++专门推出的语法，new和delete内部会自动调用构造函数和析构函数，而malloc和free则不会。

这是new和malloc的第二大区别，其实new的内部实现最终还是调用malloc，只不过增加了分配失败抛异常和调用构造函数的代码，这样更加面向对象。抛异常这种处理方式比返回值的处理方式更加面向对象，所以更推荐采用抛异常的方式而非返回值的方式。

delete和free的区别则只有一点，那就是会调用析构函数，而不存在抛异常，毕竟free本身就不存在什么释放失败的说法。

* malloc和free

```c++
#include <iostream>
using namespace std;

void test() {
    // 在堆区开辟4个字节的内存，我们用整型指针来接收这块内存的首地址，代表我们想往这块内存里存储整型
    // 这里出现了指针，就一定有两块内存，局部变量p本身所对应的栈内存和4个字节的堆内存
    // 对于那块堆内存，我们只能拿到它的地址————即存储在局部变量p所对应的栈内存里，所以要操作那块堆内存就只能通过指针变量来操作了
    int *p = (int *)malloc(4);
    if (p == NULL) {
        cout << "开辟堆内存失败" << endl;
        return;
    }
    // 我们知道拿到p就是拿到了那块堆内存的地址，拿到*p就是拿到那块堆内存的值
    *p = 10;
    // 读取这块内存里的数据
    cout << "堆内存：" << *p << endl; // 堆内存：10
    
    // 释放堆内存
    free(p);
    // free函数调用后堆内存是释放了，但指针变量p还是指向那段堆内存的，也就是说是个野指针，所以要把指针赋值为NULL避免野指针
    p = NULL;
}
```

```c++
#include <iostream>
using namespace std;

void test() {
    // 在堆区开辟4个字节的内存，我们用char类型指针来接收这块内存的首地址，代表我们想往这块内存里存储char类型，但是因为char类型只占1个字节，不足4个字节，所以这里其实代表的是开辟了一个char数组、能存放4个元素
    // 这里出现了指针，就一定有两块内存，局部变量p本身所对应的栈内存和4个字节的堆内存
    // 对于那块堆内存，我们只能拿到它的地址————即存储在局部变量p所对应的栈内存里，所以要操作那块堆内存就只能通过指针变量来操作了
    char *p = (char *)malloc(4);
    if (p == NULL) {
        cout << "开辟堆内存失败" << endl;
        return;
    }
    // 我们知道拿到p就是拿到了那块堆内存的地址，拿到*p就是拿到那块堆内存的值
    *p = 10;
    *(p + 1) = 20;
    *(p + 2) = 30;
    *(p + 3) = 40;
//    p[0] = 10;
//    p[1] = 20;
//    p[2] = 30;
//    p[3] = 40;
    // 读取这块内存里的数据
    cout << "堆内存：" << *p << *(p + 1) << *(p + 2) << *(p + 3)<< endl; // 堆内存：10 20 30 40
//    cout << "堆内存：" << p[0] << p[1] << p[2] << p[3] << endl; // 堆内存：10 20 30 40
    
    // 释放堆内存
    free(p);
    // free函数调用后堆内存是释放了，但指针变量p还是指向那段堆内存的，也就是说是个野指针，所以要把指针赋值为NULL避免野指针
    p = NULL;
}
```

* new和delete

```c++
#include <iostream>
using namespace std;

void test() {
    // 只要一见到new，那就必然是在堆区开辟内存，new后面跟着什么类型就代表我们想往这块内存里存储什么类型的数据，这里是在堆区开辟sizeof(int)个字节的内存，我们用整型指针来接收这块内存的首地址
    // 这里出现了指针，就一定有两块内存，局部变量p本身所对应的栈内存和4个字节的堆内存
    // 对于那块堆内存，我们只能拿到它的地址————即存储在局部变量p所对应的栈内存里，所以要操作那块堆内存就只能通过指针变量来操作了
    int *p = new int();
    if (p == NULL) {
        cout << "开辟堆内存失败" << endl;
        return;
    }
    // 我们知道拿到p就是拿到了那块堆内存的地址，拿到*p就是拿到那块堆内存的值
    *p = 10;
    // 读取这块内存里的数据
    cout << "堆内存：" << *p << endl; // 堆内存：10
    
    // 释放堆内存
    delete p;
    // delete调用后堆内存是释放了，但指针变量p还是指向那段堆内存的，也就是说是个野指针，所以要把指针赋值为NULL避免野指针
    p = NULL;
}
```

```c++
#include <iostream>
using namespace std;

void test() {
    // 只要一见到new []，那就必然是在堆区开辟内存，new和[]中间夹着什么类型就代表我们想往这块数组内存里存储什么类型的数据，这里是在堆区开辟sizeof(char) * 4个字节的内存，我们用char类型指针来接收这块内存的首地址
    // 这里出现了指针，就一定有两块内存，局部变量p本身所对应的栈内存和4个字节的堆内存
    // 对于那块堆内存，我们只能拿到它的地址————即存储在局部变量p所对应的栈内存里，所以要操作那块堆内存就只能通过指针变量来操作了
    char *p = new char[4]();
    if (p == NULL) {
        cout << "开辟堆内存失败" << endl;
        return;
    }
    // 我们知道拿到p就是拿到了那块堆内存的地址，拿到*p就是拿到那块堆内存的值
    *p = 10;
    *(p + 1) = 20;
    *(p + 2) = 30;
    *(p + 3) = 40;
//    p[0] = 10;
//    p[1] = 20;
//    p[2] = 30;
//    p[3] = 40;
    // 读取这块内存里的数据
    cout << "堆内存：" << *p << *(p + 1) << *(p + 2) << *(p + 3)<< endl; // 堆内存：10 20 30 40
//    cout << "堆内存：" << p[0] << p[1] << p[2] << p[3] << endl; // 堆内存：10 20 30 40
    
    // 释放堆内存
    delete[] p;
    // delete调用后堆内存是释放了，但指针变量p还是指向那段堆内存的，也就是说是个野指针，所以要把指针赋值为NULL避免野指针
    p = NULL;
}
```

###### 3.2、智能指针

传统指针存在的问题：

* 需要手动管理内存

  ```c++
  class Person {};
  
  int main() {
      // person是一个传统指针，指向了堆区的一段内存
      Person *person = new Person();
      // 有new就必须得有delete，在合适的时机我们需要手动释放堆区的那段内存，这就是手动管理内存
      delete person;
      
      return 0;
  }
  ```

* 容易产生内存泄漏（忘记释放、释放前出现异常导致执行不到释放的代码等）

  ```c++
  class Person {};
  
  int main() {
      Person *person = new Person();
      // 忘记释放，会产生内存泄漏
  //    delete person;
      
      return 0;
  }
  ```

  ```c++
  void fun() {
      throw "Error";
  }
  
  class Person {};
  
  int main() {
      Person *person = new Person();
      
      fun();
      
      // 释放前出现异常导致执行不到释放的代码，会产生内存泄漏
      delete person;
      
      return 0;
  }
  ```

* 容易产生野指针访问（释放之后忘记置空且继续访问该指针）

  ```c++
  class Person {
  public:
      int m_age;
      
      Person() {
          m_age = 0;
      }
  };
  
  int main() {
      Person *person = new Person();
      delete person;
      // 释放之后忘记置空且继续访问该指针，会产生野指针访问
  //    person = nullptr;
      person->m_age = 18;
      
      return 0;
  }
  ```

智能指针的出现就是为了解决传统指针存在的问题：

* auto_ptr：属于C++98标准，在C++11标准中已经不推荐使用了，因为它有缺陷
* shared_ptr：属于C++11标准，推荐使用
* unique_ptr：属于C++11标准，推荐使用

###### 3.2.1 auto_ptr

传统指针的使用格式：

```
// Person *是指针类型，指针变量person指向了堆区的一个对象
Person *person = new Person(18);
delete sperson;
```

auto_ptr的使用格式：

```
// auto_ptr<Person>是指针类型，指针变量person指向了堆区的一个对象
auto_ptr<Person> person(new Person());
```

auto_ptr的一大特点就是指针变量一旦释放，那么指针变量所指向的堆内存也会自动释放，这就解决了传统指针存在的三大问题。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;
    
    void run() {
        cout << "run()" << " " << m_age << endl;
    }
    
    Person() {
        cout << "Person()" << endl;
        
        m_age = 0;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        auto_ptr<Person> person(new Person());
        person->m_age = 18;
        person->run();
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // run() 18
    // ~Person()
    // 2
    
    return 0;
}
```

那auto_ptr是怎么实现这个效果的呢？其实也很简单，auto_ptr的本质其实一个类，这个类内部有个指针会指向我们堆区的那个对象，而我们在外界创建的auto_ptr指针变量其实并非一个真正的指针变量、就是个普通的auto_ptr类型的对象而已，那么当该auto_ptr类型的对象出了作用域释放时必然会触发它的析构函数，所以我们只要在析构函数里delete掉auto_ptr内部的指针，我们堆区的那个对象自然就可以释放了，当然为了能让“auto_ptr类型的对象”这个普通的对象在外界使用者看来的确是个指针，我们还需要重载一下\*和->运算符，这就是auto_ptr的基本实现原理。

```c++
#include <iostream>
using namespace std;

template <typename T> class AutoPtr {
private:
    T *m_ptr;
    
public:
    AutoPtr(T *ptr) {
        m_ptr = ptr;
    }
    
    ~AutoPtr() {
        delete m_ptr;
    }
    
    T& operator*() {
        return *m_ptr;
    }
    
    T* operator->() {
        return m_ptr;
    }
};

class Person {
public:
    int m_age;
    
    void run() {
        cout << "run()" << " " << m_age << endl;
    }
    
    Person() {
        cout << "Person()" << endl;
        
        m_age = 0;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        AutoPtr<Person> person(new Person());
        person->m_age = 18;
        person->run();
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // run() 18
    // ~Person()
    // 2
    
    return 0;
}
```

但auto_ptr也有缺陷，那就是它不能用在数组身上，下面的例子中我们看到构造函数调用了三次，但是析构函数才调用了一次，主要就是因为我们用了new []，但是auto_ptr内部的实现确实delete而非delete []，那怎么解决这个问题呢？shared_ptr！

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;
    
    void run() {
        cout << "run()" << " " << m_age << endl;
    }
    
    Person() {
        cout << "Person()" << endl;
        
        m_age = 0;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        auto_ptr<Person> person(new Person[3]());
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // Person()
    // Person()
    // run() 18
    // ~Person()
    // 2
    
    return 0;
}
```

###### 4.2 引用计数式内存管理、shared_ptr、循环引用导致内存泄漏、weak_ptr

传统指针的使用格式：

```
// Person *是指针类型，指针变量person指向了堆区的一个对象
Person *person = new Person(18);
delete sperson;
```

shared_ptr的使用格式：

```
// shared_ptr<Person>是指针类型，指针变量person指向了堆区的一个对象
shared_ptr<Person> person(new Person());
```

shared_ptr非常类似于OC里的__strong指针，使用shared_ptr指针变量指向对象会对对象产生强引用、对象的引用计数会加1，shared_ptr指针变量出了作用域时会释放对对象的强引用、对象的引用计数会减1，当对象的引用计数为0时就会自动释放对象，这也能解决传统指针存在的三大问题。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    Person() {
        cout << "Person()" << endl;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        shared_ptr<Person> person(new Person());
        cout << person << "对象的引用计数为：" << person.use_count() << endl; // 0x600000004040对象的引用计数为：1
        {
            shared_ptr<Person> person1(person);
            cout << person << "对象的引用计数为：" << person.use_count() << endl; // 0x600000004040对象的引用计数为：2
            {
                shared_ptr<Person> person2 = person1;
                cout << person << "对象的引用计数为：" << person.use_count() << endl; // 0x600000004040对象的引用计数为：3
            }
            cout << person << "对象的引用计数为：" << person.use_count() << endl; // 0x600000004040对象的引用计数为：2
        }
        cout << person << "对象的引用计数为：" << person.use_count() << endl; // 0x600000004040对象的引用计数为：1
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // 0x600000008030对象的引用计数为：1
    // 0x600000008030对象的引用计数为：2
    // 0x600000008030对象的引用计数为：3
    // 0x600000008030对象的引用计数为：2
    // 0x600000008030对象的引用计数为：1
    // ~Person()
    // 2
    
    return 0;
}
```

同时shared_ptr也能解决auto_ptr不能指向数组的问题。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;
    
    void run() {
        cout << "run()" << " " << m_age << endl;
    }
    
    Person() {
        cout << "Person()" << endl;
        
        m_age = 0;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        shared_ptr<Person []> person(new Person[3]);
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // Person()
    // Person()
    // ~Person()
    // ~Person()
    // ~Person()
    // ~Person()
    // 2
    
    return 0;
}
```

引用计数式内存管理必然会导致循环引用，下面的代码中person对象和car对象就构成了循环引用，导致了内存泄漏。

```c++
#include <iostream>
using namespace std;

// 类的前置声明
class Person;
class Car;

class Person {
public:
    shared_ptr<Car> m_car; // 强引用
    
    Person() {
        cout << "Person()" << endl;        
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

class Car {
public:
    shared_ptr<Person> m_owner; // 强引用
    
    Car() {
        cout << "Car()" << endl;        
    }
    ~Car() {
        cout << "~Car()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        shared_ptr<Person> person(new Person());
        shared_ptr<Car> car(new Car());
        
        person->m_car = car;
        car->m_owner = person;
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // Car()
    // 2
    
    return 0;
}
```

但是只要我们把循环引用中的一个强指针的换成弱指针，就可以解决问题，weak_ptr不会使对象的引用计数加1。

```c++
#include <iostream>
using namespace std;

// 类的前置声明
class Person;
class Car;

class Person {
public:
    shared_ptr<Car> m_car; // 强引用
    
    Person() {
        cout << "Person()" << endl;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

class Car {
public:
    weak_ptr<Person> m_owner; // 弱引用
    
    Car() {
        cout << "Car()" << endl;
    }
    ~Car() {
        cout << "~Car()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        shared_ptr<Person> person(new Person());
        shared_ptr<Car> car(new Car());
        
        person->m_car = car;
        car->m_owner = person;
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // Car()
    // ~Person()
    // ~Car()
    // 2
    
    return 0;
}
```

###### 4.3 unique_ptr

传统指针的使用格式：

```
// Person *是指针类型，指针变量person指向了堆区的一个对象
Person *person = new Person(18);
delete sperson;
```

unique_ptr的使用格式：

```
// unique_ptr<Person>是指针类型，指针变量person指向了堆区的一个对象
unique_ptr<Person> person(new Person());
```

unique_ptr的主要特点是只能同一时间只能有一个指针指向某个堆区的对象，其它的跟auto_ptr差不多，当然它也解决了auto_ptr不能指向数组的问题。以后建议用shared_ptr和unique_ptr，两者的选择就在于你希望几个指针指向某个堆区的对象。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    Person() {
        cout << "Person()" << endl;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        unique_ptr<Person> person(new Person());
        
        // 不能有其它指针指向person对象了
//        unique_ptr<Person> person1(person);
        
        // 但是我们可以把指向权交给另外一个指针，这样依然还是只有一个指针指向堆区的对象，std::move
        unique_ptr<Person> person1 = move(person);
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // run() 18
    // ~Person()
    // 2
    
    return 0;
}
```
