## 四、多线程

#### 1、基本使用

```c++
#include <iostream>
#include <thread>
using namespace std;

// 我们创建一个线程来改变x的值
int x = 0;

// 新线程里想做的事
// 改变[count]次x
void add(int count) {
    for (int i = 0; i < count; i++) {
        x++;
    }
}

int main() {
    cout << "main()函数开始" << endl;
    
    // 创建新线程对象并启动
    // 第一个参数可以是个函数名，也可以是个匿名函数
    // 第二个参数是函数的参数，是个可变参数，可以传多个、没有就不传
    thread *t = new thread(add, 1000);
    
    // 等待线程t执行完
    // 这个demo如果不等待的话，主线程就直接return 0程序结束了
    t->join();
    
    delete t;
    
    cout << x << endl;
    
    cout << "main()函数结束" << endl;
    
    // 控制台打印：
    // main()函数开始
    // 1000
    // main()函数结束（被t->join()卡住了）
    
    return 0;
}
```

#### 2、数据竞争问题

```c++
#include <iostream>
#include <thread>
using namespace std;

// 我们创建两个线程来改变x的值
int x = 0;

// 新线程里想做的事
// 改变[count]次x
void add(int count) {
    for (int i = 0; i < count; i++) {
        x++;
    }
}

int main() {
    cout << "main()函数开始" << endl;
    
    thread *t = new thread(add, 1000);
    thread *t1 = new thread(add, 1000);
    
    t->join();
    t1->join();
    
    delete t;
    delete t1;
    
    cout << x << endl;
    
    cout << "main()函数结束" << endl;
    
    // 控制台打印：
    // main()函数开始
    // 1175（本来应该是2000，但是因为数据竞争问题导致数据出错）
    // main()函数结束
    
    return 0;
}
```

#### 3、加锁解决数据竞争问题

```c++
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

// 创建一个全局的互斥锁
mutex mtx;

// 我们创建两个线程来改变x的值
int x = 0;

// 新线程里想做的事
// 改变[count]次x
void add(int count) {
    // 这种加锁方式结果是对的，这种加锁方式相当于是把两个线程搞成串行的了，即线程t完整地把任务————整个for循环————执行完，线程t1才能开始执行任务
    // 加锁
    mtx.lock();
    for (int i = 0; i < count; i++) {
        x++;
    }
    // 解锁
    mtx.unlock();
    
    // 这种加锁方式结果也是对的，这种加锁方式相当于两个线程还是并行的，即线程t加锁、x++一下、解锁，然后线程t1加锁、x++一下、解锁，如此循环，虽然是并行执行，但是因为for循环在频繁地加锁解锁，而加锁解锁又是耗性能的，所以这里的效率反而不如上面的串行执行，因此加锁粒度要注意
//    for (int i = 0; i < count; i++) {
//        // 加锁
//        mtx.lock();
//        x++;
//        // 解锁
//        mtx.unlock();
//    }
}

int main() {
    cout << "main()函数开始" << endl;
    
    thread *t = new thread(add, 1000);
    thread *t1 = new thread(add, 1000);
    
    t->join();
    t1->join();
    
    delete t;
    delete t1;
    
    cout << x << endl;
    
    cout << "main()函数结束" << endl;
    
    // 控制台打印：
    // main()函数开始
    // 2000
    // main()函数结束
    
    return 0;
}
```

