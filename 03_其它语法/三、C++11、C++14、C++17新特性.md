## 三、C++11、C++14、C++17的新特性

我们前面学习的是C++98，现在补充一些C++11、C++14、C++17有用的新特性。

#### 1、类型推断auto

之前我们定义变量必须指明变量的数据类型，这样编译器才能知道该为这个变量分配多大的内存。

```c++
#include <iostream>
using namespace std;

int main() {
    char c = 'A';
    int i = 10;
    double d = 20.2;
    bool b = false;
    
    class Person {};
    Person *person = new Person();
    delete person;
    
    cout << sizeof(c) << endl; // 1
    cout << sizeof(i) << endl; // 4
    cout << sizeof(d) << endl; // 8
    cout << sizeof(b) << endl; // 1
    
    cout << sizeof(person) << endl; // 8
    
    return 0;
}
```

现在我们定义变量不必指明变量的数据类型，全部用auto替代即可，编译器能从我们为变量赋的初始值推断出这个变量的数据类型，进而知道该为这个变量分配多大的内存。这么做可以大大简化我们开发者的编程工作，本质来说无非就是在编译时编译器多做点事而已，编译出来的可执行文件跟之前是一样的，运行时的运行效率也不受影响。

```c++
#include <iostream>
using namespace std;

int main() {
    auto c = 'A';
    auto i = 10;
    auto d = 20.2;
    auto b = false;
    
    class Person {};
    auto person = new Person();
    delete person;
    
    cout << sizeof(c) << endl; // 1
    cout << sizeof(i) << endl; // 4
    cout << sizeof(d) << endl; // 8
    cout << sizeof(b) << endl; // 1
    
    cout << sizeof(person) << endl; // 8
    
    return 0;
}
```

#### 2、空指针nullptr

之前我们是用NULL来代表一个空指针，但是我们知道NULL的本质其实就是0。

```c++
#include <iostream>
using namespace std;

int main() {
    int *ip = NULL;
    cout << ip << endl; // 0
    cout << NULL << endl; // 0
        
    return 0;
}
```

```c++
#define NULL 0
```

所以使用NULL存在二义性。

```c++
#include <iostream>
using namespace std;

// 我们是用NULL来代表一个空指针，所以可以调用这个函数
void fun(int *i) {
    cout << "fun(int *)" << " " << i << endl;
}

// 我们知道NULL的本质其实就是0，所以也可以调用这个函数
void fun(int i) {
    cout << "fun(int)" << " " << i << endl;
}

int main() {
    fun(NULL); // 编译报错，fun函数的调用存在二义性
    
    return 0;
}
```

而使用nullptr则不存在二义性，因为它的本质不是0，而是(void \*)0。

```c++
#include <iostream>
using namespace std;

void fun(int *i) {
    cout << "fun(int *)" << " " << i << endl;
}

void fun(int i) {
    cout << "fun(int)" << " " << i << endl;
}

int main() {
    fun(nullptr); // 编译通过，fun(int *) 0
    
    return 0;
}
```

因此现在我们建议用nullptr来代表一个空指针，不要再用NULL。

```c++
#include <iostream>
using namespace std;

int main() {
    int *ip = nullptr;
    cout << ip << endl; // 0
    cout << nullptr << endl; // nullptr
        
    return 0;
}
```

#### 3、Lambda表达式（Block/闭包表达式/匿名函数）

C++里的Lambda表达式在功能上类似于OC里的Block、Swift里的闭包表达式、Dart里的匿名函数，叫它什么都可以，它的本质就是一个函数，只是没有名字而已，C++里匿名函数的格式为：

```
[匿名函数要捕获的变量列表] (匿名函数的参数列表) -> 匿名函数的返回值 {
    // 匿名函数的执行体
}
```

###### 3.1 匿名函数的应用场景

C++里函数不是一等公民，但函数指针是一等公民，而匿名函数一般都要跟函数指针一起用，所以我们可以从一等公民的角度来考虑匿名函数的应用场景：

* 立即执行的函数优先考虑使用匿名函数，常用来初始化不方便初始化的属性

```swift
lazy var tableView: UITableView = {
    let tableView = UITableView(frame: CGRect(x: 0, y: 0, width: 414, height: 736), style: .plain)
    tableView.dataSource = self
    tableView.delegate = self
    tableView.register(UITableViewCell.self, forCellReuseIdentifier: cellReuseId)
    return tableView
}()
```

* 匿名函数可以赋值给一个变量供将来调用，也就是说它不能单独存在，因为它单独存在没有意义，它没有名字将来你拿什么调用它，常用来做属性类型的callback

```c++
#include <iostream>
using namespace std;

int main() {
    // 匿名函数的类型为int (int, int)，定义一个函数指针来接收匿名函数
    int (*fp)(int, int) = [] (int i1, int i2) -> int {
        return i1 + i2;
    };
    cout << fp(10, 20) << endl; // 30
        
    return 0;
}
```

* 我们可以把闭包表达式作为另一个函数的参数来使用，也就是我们常说的回调，常用来函数参数类型的callback

```c++
#include <iostream>
using namespace std;

// 加法函数
int add(int a, int b) {
    return a + b;
}

// 减法函数
int sub(int a, int b) {
    return a - b;
}

// 乘法函数
int mult(int a, int b) {
    return a * b;
}

// 除法函数
int divi(int a, int b) {
    return a / b;
}

// 这里的int (int, int)一个函数类型，calc_t是该函数类型的别名
typedef int (calc_t)(int, int);
// 再定义一个函数类型
typedef void (callback_t)(int);
// 这里我们通过回调函数的方式把calc函数的结果告诉外界
void calc(calc_t *calc, int a, int b, callback_t *callback) {
    int ret = calc(a, b);
    callback(ret);
}

int main() {
    calc(add, 10, 20, [] (int ret) -> void {
        cout << ret << endl; // 30
    });
        
    return 0;
}
```

* 我们可以把匿名函数作为另一个函数的返回值来使用，不过这个一般需要和第2条连用，不常用

```c++
#include <iostream>
using namespace std;

auto getFun() {
    int (*fp)(int, int) = [] (int i1, int i2) -> int {
        return i1 + i2;
    };
    
    return fp;
}

int main() {
    auto fun = getFun();
    cout << fun(10, 20) << endl; // 30
    
    return 0;
}
```

###### 3.2 匿名函数捕获变量

* 匿名函数会捕获外界的局部变量，分为值捕获和地址捕获，

```c++
#include <iostream>
using namespace std;

int main() {
    int i = 10;
    int i1 = 20;
    
    // 1、值捕获i，地址捕获i1
    // 本质其实就是拷贝一份i的值存进匿名函数的栈帧里、拷贝一份i1的地址存进匿名函数的栈帧里
    auto fp = [i, &i1] () -> void {
        cout << i << endl; // 10
        cout << i1 << endl; // 21
        
        // 3、值捕获的话，我们不可以在匿名函数内部修改外界局部变量的值
        // 地址捕获的话，我们可以在匿名函数内部修改外界局部变量的值
        // 这很好理解，本质还是因为这里的i是栈帧里面的值，跟外界压根不是一块内存，所以不可以修改
        // 而这里的i1其实是存储了一份地址，和外面的变量指向同一块内存，所以可以修改
//        i = 12; // 编译报错
        i1 = 22; // 编译通过
        cout << i << endl; // 10
        cout << i1 << endl; // 22
    };
    
    // 2、因此这里修改i不会影响匿名函数栈帧里的i，这里修改i1会影响匿名函数栈帧里的i1
    i = 11;
    i1 = 21;
    
    fp();
    
    return 0;
}
```

* 匿名函数不会捕获外界的静态局部变量、全局变量、静态全局变量，因为这些变量都是存储在静态全局区的，它们在项目中的任何地方都可以直接访问，所以没必要捕获，匿名函数里直接访问就可以了

```c++
#include <iostream>
using namespace std;

int i1 = 20;
static int i2 = 30;

int main() {
    static int i = 10;
    
    // 1、静态局部变量、全局变量、静态全局变量不需要捕获，因为它们都是存储在静态全局区的
    auto fp = [] () -> void {
        cout << i << endl; // 11
        cout << i1 << endl; // 21
        cout << i2 << endl; // 31
        
        // 3、直接使用即可
        i = 12; // 编译报错
        i1 = 22; // 编译通过
        i2 = 32; // 编译通过
        cout << i << endl; // 12
        cout << i1 << endl; // 22
        cout << i2 << endl; // 32
    };
    
    // 2、因此这里修改会影响i、i1、i2
    i = 11;
    i1 = 21;
    i2 = 31;
    
    fp();
    
    return 0;
}
```

#### 4、异常

###### 4.1 开发中的错误

在开发程序的过程中，会遇到各种各样的错误，错误主要分为三类：

* 语法错误：比如我们把一个string类型赋值给int类型【int i = "ABC";】，C++语法就不允许你这么干，这就是语法错误，语法错误会导致编译报错，程序根本就运行不起来

* 逻辑错误：比如我们本来想让【i += 1】的，但是不小心写成了【i -= 1】，从而导致结果出错了，这就是逻辑错误，逻辑错误编译是能通过的，程序也能运行起来，只不过程序运行时会有bug，但程序不会崩溃

* 异常：比如堆OOM了、空指针了等等，这些都是在程序运行过程中才产生的意外，这就是异常，异常编译是能通过的，程序也能运行起来，只不过异常如果没被处理的话程序运行时会崩溃

  ```c++
  // 堆OOM举例
  void test() {
      // 比如我们要申请一段连续的堆内存，堆内存总共才多大啊，我们却要100000000000000 * 4个字节
      // 编译是不会报错的，程序也能跑起来，但是执行到这就崩了，因为堆OOM了
      //
      // libc++abi: terminating with uncaught exception of type std::bad_alloc: std::bad_alloc
      int *p = new int[100000000000000];
      delete[] p;
  }
  
  int main() {
      test();
      
      return 0;
  }
  ```

  ```c++
  // 空指针举例
  void test() {
      // 比如我们访问一个空指针
      // 编译是不会报错的，程序也能跑起来，但是执行到这就崩了，因为C++里是不允许访问空指针的
      //
      // BAD_ACCESS
      int *p = nullptr;
      *p = 10;
  }
  
  int main() {
      test();
      
      return 0;
  }
  ```

###### 4.2 捕获异常

程序产生了异常，我们一般称之为：抛出了异常，我们可以通过try-catch来捕获异常并处理。

```
try {
    把可能会抛出异常的代码写在try里
} catch (const exception &e) { 捕获C++标准异常，C++标准异常都继承自exception类
    然后在catch里看看你想对异常做些什么处理：
    
    打印异常描述
    cout << e.what() << endl;
    
    一些其它的处理
    ...
} catch (const 自定义异常类型 &e) { 捕获自定义异常
    然后在catch里看看你想对异常做些什么处理：
    
    打印异常描述
    cout << e.what() << endl;
    
    一些其它的处理
    ...
}
```

```c++
#include <iostream>
using namespace std;

void test() {
    int *p = new int[100000000000000];
    delete[] p;
}

int main() {
  	// 通过try-catch来处理异常
    try {
        test();
    } catch (const exception &e) {
        cout << e.what() << endl; // std::bad_alloc
    }
    
    return 0;
}
```

###### 4.3 自定义异常、抛出异常

C++标准异常会在某些情况下自动抛出，除此之外我们还可以自定义异常并抛出。

```c++
#include <iostream>
using namespace std;

// 所有异常的基类
class Exception {
public:
    virtual string what() const = 0;
};

// 除法异常
class DiviException : public Exception {
public:
    string what() const {
        return "除数不能为0";
    }
};

int divi(int i1, int i2) {
    // 顺带说一下这里我们为什么要抛出异常
    // 其实我们在编写代码的时候，对于一些意外，可以有多种处理方式
    // 比如这里如果i2为0，我们也可以返回一个特殊的值如-1来代表出错了，但是这种处理方式好像不太适合这个场景，因为-1完全有可能是个有效的返回值
    // 因此我们才选择了抛出异常
    if (i2 == 0) {
        throw DiviException();
    }
    
    return i1 / i2;
}

int main() {
    try {
        divi(10, 0);
    } catch (const Exception &e) {
        cout << e.what() << endl; // 除数不能为0
    }
    
    return 0;
}
```

#### 5、智能指针

传统指针存在的问题：

* 需要手动管理内存

  ```c++
  class Person {};
  
  int main() {
      // person是一个传统指针，指向了堆区的一段内存
      Person *person = new Person();
      // 有new就必须得有delete，在合适的时机我们需要手动释放堆区的那段内存，这就是手动管理内存
      delete person;
      
      return 0;
  }
  ```

* 容易产生内存泄漏（忘记释放、释放前出现异常导致执行不到释放的代码等）

  ```c++
  class Person {};
  
  int main() {
      Person *person = new Person();
      // 忘记释放，会产生内存泄漏
  //    delete person;
      
      return 0;
  }
  ```

  ```c++
  void fun() {
      throw "Error";
  }
  
  class Person {};
  
  int main() {
      Person *person = new Person();
      
      fun();
      
      // 释放前出现异常导致执行不到释放的代码，会产生内存泄漏
      delete person;
      
      return 0;
  }
  ```

* 容易产生野指针访问（释放之后忘记置空且继续访问该指针）

  ```c++
  class Person {
  public:
      int m_age;
      
      Person() {
          m_age = 0;
      }
  };
  
  int main() {
      Person *person = new Person();
      delete person;
      // 释放之后忘记置空且继续访问该指针，会产生野指针访问
  //    person = nullptr;
      person->m_age = 18;
      
      return 0;
  }
  ```

智能指针的出现就是为了解决传统指针存在的问题：

* auto_ptr：属于C++98标准，在C++11标准中已经不推荐使用了，因为它有缺陷
* shared_ptr：属于C++11标准，推荐使用
* unique_ptr：属于C++11标准，推荐使用

###### 5.1 auto_ptr

传统指针的使用格式：

```
// Person *是指针类型，指针变量person指向了堆区的一个对象
Person *person = new Person(18);
delete sperson;
```

auto_ptr的使用格式：

```
// auto_ptr<Person>是指针类型，指针变量person指向了堆区的一个对象
auto_ptr<Person> person(new Person());
```

auto_ptr的一大特点就是指针变量一旦释放，那么指针变量所指向的堆内存也会自动释放，这就解决了传统指针存在的三大问题。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;
    
    void run() {
        cout << "run()" << " " << m_age << endl;
    }
    
    Person() {
        cout << "Person()" << endl;
        
        m_age = 0;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        auto_ptr<Person> person(new Person());
        person->m_age = 18;
        person->run();
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // run() 18
    // ~Person()
    // 2
    
    return 0;
}
```

那auto_ptr是怎么实现这个效果的呢？其实也很简单，auto_ptr的本质其实一个类，这个类内部有个指针会指向我们堆区的那个对象，而我们在外界创建的auto_ptr指针变量其实并非一个真正的指针变量、就是个普通的auto_ptr类型的对象而已，那么当该auto_ptr类型的对象出了作用域释放时必然会触发它的析构函数，所以我们只要在析构函数里delete掉auto_ptr内部的指针，我们堆区的那个对象自然就可以释放了，当然为了能让“auto_ptr类型的对象”这个普通的对象在外界使用者看来的确是个指针，我们还需要重载一下->运算符，这就是auto_ptr的基本实现原理。

```c++
#include <iostream>
using namespace std;

template <typename T> class AutoPtr {
private:
    T *m_ptr;
    
public:
    AutoPtr(T *ptr) {
        m_ptr = ptr;
    }
    
    ~AutoPtr() {
        delete m_ptr;
    }
    
    T* operator->() {
        return m_ptr;
    }
};

class Person {
public:
    int m_age;
    
    void run() {
        cout << "run()" << " " << m_age << endl;
    }
    
    Person() {
        cout << "Person()" << endl;
        
        m_age = 0;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        AutoPtr<Person> person(new Person());
        person->m_age = 18;
        person->run();
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // run() 18
    // ~Person()
    // 2
    
    return 0;
}
```

但auto_ptr也有缺陷，那就是它不能用在数组身上，下面的例子中我们看到构造函数调用了三次，但是析构函数才调用了一次，主要就是因为我们用了new []，但是auto_ptr内部的实现确实delete而非delete []，那怎么解决这个问题呢？shared_ptr！

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;
    
    void run() {
        cout << "run()" << " " << m_age << endl;
    }
    
    Person() {
        cout << "Person()" << endl;
        
        m_age = 0;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        auto_ptr<Person> person(new Person[3]());
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // Person()
    // Person()
    // run() 18
    // ~Person()
    // 2
    
    return 0;
}
```

###### 5.2 引用计数式内存管理、shared_ptr、循环引用、weak_ptr

传统指针的使用格式：

```
// Person *是指针类型，指针变量person指向了堆区的一个对象
Person *person = new Person(18);
delete sperson;
```

shared_ptr的使用格式：

```
// shared_ptr<Person>是指针类型，指针变量person指向了堆区的一个对象
shared_ptr<Person> person(new Person());
```

shared_ptr非常类似于OC里的__strong指针，使用shared_ptr指针变量指向对象会对对象产生强引用、对象的引用计数会加1，shared_ptr指针变量出了作用域时会释放对对象的强引用、对象的引用计数会减1，当对象的引用计数为0时就会自动释放对象，这也能解决传统指针存在的三大问题。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    Person() {
        cout << "Person()" << endl;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        shared_ptr<Person> person(new Person());
        cout << person << "对象的引用计数为：" << person.use_count() << endl; // 0x600000004040对象的引用计数为：1
        {
            shared_ptr<Person> person1(person);
            cout << person << "对象的引用计数为：" << person.use_count() << endl; // 0x600000004040对象的引用计数为：2
            {
                shared_ptr<Person> person2 = person1;
                cout << person << "对象的引用计数为：" << person.use_count() << endl; // 0x600000004040对象的引用计数为：3
            }
            cout << person << "对象的引用计数为：" << person.use_count() << endl; // 0x600000004040对象的引用计数为：2
        }
        cout << person << "对象的引用计数为：" << person.use_count() << endl; // 0x600000004040对象的引用计数为：1
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // 0x600000008030对象的引用计数为：1
    // 0x600000008030对象的引用计数为：2
    // 0x600000008030对象的引用计数为：3
    // 0x600000008030对象的引用计数为：2
    // 0x600000008030对象的引用计数为：1
    // ~Person()
    // 2
    
    return 0;
}
```

同时shared_ptr也能解决auto_ptr不能指向数组的问题。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    int m_age;
    
    void run() {
        cout << "run()" << " " << m_age << endl;
    }
    
    Person() {
        cout << "Person()" << endl;
        
        m_age = 0;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        shared_ptr<Person []> person(new Person[3]);
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // Person()
    // Person()
    // ~Person()
    // ~Person()
    // ~Person()
    // ~Person()
    // 2
    
    return 0;
}
```

引用计数式内存管理必然会导致循环引用，下面的代码中person对象和car对象就构成了循环引用，导致了内存泄漏。

```c++
#include <iostream>
using namespace std;

// 类的前置声明
class Person;
class Car;

class Person {
public:
    shared_ptr<Car> m_car; // 强引用
    
    Person() {
        cout << "Person()" << endl;        
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

class Car {
public:
    shared_ptr<Person> m_owner; // 强引用
    
    Car() {
        cout << "Car()" << endl;        
    }
    ~Car() {
        cout << "~Car()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        shared_ptr<Person> person(new Person());
        shared_ptr<Car> car(new Car());
        
        person->m_car = car;
        car->m_owner = person;
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // Car()
    // 2
    
    return 0;
}
```

但是只要我们把循环引用中的一个强指针的换成弱指针，就可以解决问题，weak_ptr不会使对象的引用计数加1。

```c++
#include <iostream>
using namespace std;

// 类的前置声明
class Person;
class Car;

class Person {
public:
    shared_ptr<Car> m_car; // 强引用
    
    Person() {
        cout << "Person()" << endl;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

class Car {
public:
    weak_ptr<Person> m_owner; // 弱引用
    
    Car() {
        cout << "Car()" << endl;
    }
    ~Car() {
        cout << "~Car()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        shared_ptr<Person> person(new Person());
        shared_ptr<Car> car(new Car());
        
        person->m_car = car;
        car->m_owner = person;
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // Car()
    // ~Person()
    // ~Car()
    // 2
    
    return 0;
}
```

###### 5.3 unique_ptr

传统指针的使用格式：

```
// Person *是指针类型，指针变量person指向了堆区的一个对象
Person *person = new Person(18);
delete sperson;
```

unique_ptr的使用格式：

```
// unique_ptr<Person>是指针类型，指针变量person指向了堆区的一个对象
unique_ptr<Person> person(new Person());
```

unique_ptr的主要特点是只能同一时间只能有一个指针指向某个堆区的对象，其它的跟auto_ptr差不多，当然它也解决了auto_ptr不能指向数组的问题。以后建议用shared_ptr和unique_ptr，两者的选择就在于你希望几个指针指向某个堆区的对象。

```c++
#include <iostream>
using namespace std;

class Person {
public:
    Person() {
        cout << "Person()" << endl;
    }
    ~Person() {
        cout << "~Person()" << endl;
    }
};

int main() {
    cout << 1 << endl;
    {
        unique_ptr<Person> person(new Person());
        
        // 不能有其它指针指向person对象了
//        unique_ptr<Person> person1(person);
        
        // 但是我们可以把指向权交给另外一个指针，这样依然还是只有一个指针指向堆区的对象，std::move
        unique_ptr<Person> person1 = move(person);
    }
    cout << 2 << endl;
    
    // 控制台打印：
    // 1
    // Person()
    // run() 18
    // ~Person()
    // 2
    
    return 0;
}
```

