## 三、引用类型

#### 1、引用类型是什么？

“引用类型的变量其实就是其它数据类型变量的一个别名，这两个变量对应着同一块内存，所以读写引用变量就是在读写原变量”——在高级语言使用层面给人的感觉是这样，基本数据类型、派生数据类型的变量都可以有引用——即别名。

```c++
#include <iostream>
using namespace std;

int main() {
    // i是一个int类型的变量
    int i = 10;
    // ir是i的别名，所以ir前面的数据类型要和i的数据类型int一致，而&必须跟引用变量紧挨着才表明是个引用变量
    int &ir = i;
    i = 20;
    ir = 30;
    cout << i << endl; // 30
    cout << ir << endl; // 30
    
    // ip是一个int*类型的变量
    int *ip = &i;
    // ipr是ip的别名，所以ipr前面的数据类型要和ip的数据类型int*一致，而&必须跟引用变量紧挨着才表明是个引用变量
    int *&ipr = ip;
    *ip = 40;
    *ipr = 50;
    cout << *ip << endl; // 50
    cout << *ipr << endl; // 50
    
    return 0;
}
```

#### 2、怎么使用引用类型？

* 我们必须在声明引用变量的时候就初始化，而且只能是把一个变量名赋值给引用变量、不能是一个具体的值，因为是给变量取别名，而不是给具体的值取别名；但是有个例外，常引用可以被初始化为一个具体的值，因为它赋值后就不能变了嘛，反正就是读取，那初始化一个具体的值也未尝不可，这个例外经常用在函数的参数那里，因为外界很可能不是把一个变量传给我们的引用形参，而是直接传一个具体的值

```c++
int main() {
    int i = 10;
    
    // 我们必须在声明引用变量的时候就初始化，而且只能是把一个变量名赋值给引用变量
    int &ir = i;
    // 不能是一个具体的值
//    int &ir1 = 10;
    
    // 常引用可以被初始化为一个具体的值
    int const &ir1 = 10;
    
    return 0;
}
```

* 引用变量在初始化后，就从一而终了，不能再成为别的变量的别名，也就是说引用变量在初始化后，任何再对引用变量的赋值操作都是简单的赋值，而不是让引用变量再成为别的变量的别名

```c++
#include <iostream>
using namespace std;

int main() {
    int i = 10;
    int i1 = 20;
    
    // 这里ir成为了i的别名，以后它就永远都是i的别名了
    int &ir = i;

    // 这里你可能想我们是不是又把ir变成了i1的别名呢？并没有，这里只是把i1的值20赋值给了ir————即i
    ir = i1;
        
    cout << i << endl; // 20
    cout << i1 << endl; // 20
    cout << ir << endl; // 20
    
    // 三个变量都是20，你可能想万一ir同时是i和i1的别名呢？
    // 那我们现在修改一下ir，看看到底i和i1谁被改变了
    ir = 30;
 
    cout << i << endl; // 30
    cout << i1 << endl; // 20
    cout << ir << endl; // 30
    
    return 0;
}
```

* 引用变量在声明及初始化后，以后再使用引用变量我们完全可以看做就是在使用原变量

```c++
#include <iostream>
using namespace std;

int main() {
    int i = 10;
    int &ir = i;
    
    ir = 20;
    cout << ir << endl; // 20
    
    // 完全等价于
    i = 20;
    cout << i << endl; // 20
    
    return 0;
}
```

#### 3、引用类型的本质是什么？

引用的本质其实就是指针，只不过是个弱化了的指针，所谓弱化是指指针不用初始化也能使用——即使用空指针、在初始化后还可以修改指向、可以越界访问（访问变量本身所对应内存以外的内存），而引用这个弱化指针必须初始化、在初始化后不可以修改指向、不可以越界访问，也正是因为引用的本质就是一个弱化指针，所以我们才可以通过引用来修改原变量的值。一个很经典的例子，交换两个数的值：

```c++
#include <iostream>
using namespace std;

// 直接交换是不行的
void swap(int i1, int i2) {
    i1 = i1 ^ i2;
    i2 = i1 ^ i2;
    i1 = i1 ^ i2;
}
// 通过指针可以实现
void swap_p(int *i1, int *i2) {
    *i1 = *i1 ^ *i2;
    *i2 = *i1 ^ *i2;
    *i1 = *i1 ^ *i2;
}
// 通过引用也可以实现
void swap_r(int &i1, int &i2) {
    i1 = i1 ^ i2;
    i2 = i1 ^ i2;
    i1 = i1 ^ i2;
}

int main() {
    int i = 10;
    int i1 = 20;
    
    swap(i, i1);
    cout << i << endl; // 10
    cout << i1 << endl; // 20
    
    swap_p(&i, &i1);
    cout << i << endl; // 20
    cout << i1 << endl; // 10
    
    swap_r(i, i1);
    cout << i << endl; // 10
    cout << i1 << endl; // 20
    
    return 0;
}
```

当然上面这个经典例子只是从高级语言应用层面让我们感受到引用的本质就是指针，接下来我们就从汇编层面敲定引用的本质就是指针，下面两组代码对应的汇编是一模一样的。

```c++
// C++
int main() {
    int i = 10;
    
    // 指针
    int *ip = &i;
    *ip = 20;

    return 0;
}

int main() {
    int i = 10;
    
    // 引用
    int &ir = i;
    ir = 20;

    return 0;
}
```

```assembly
// 对应的汇编
_main:
	sub	sp, sp, #16
	mov	w0, #0
	str	wzr, [sp, #12]
	add	x8, sp, #8
	mov	w9, #10
	str	w9, [sp, #8]
	str	x8, [sp]
	ldr	x9, [sp]
	mov	w8, #20
	str	w8, [x9]
	add	sp, sp, #16
	ret
	
_main:
	sub	sp, sp, #16
	mov	w0, #0
	str	wzr, [sp, #12]
	add	x8, sp, #8
	mov	w9, #10
	str	w9, [sp, #8]
	str	x8, [sp]
	ldr	x9, [sp]
	mov	w8, #20
	str	w8, [x9]
	add	sp, sp, #16
	ret
```

所以说引用对应的其实是两块内存，只不过在高级语言使用层面给人的感觉是一块内存而已。那么在高级语言使用层面我们完全可以不用去搭理引用的本质，就把它当作是一个别名来使用就行了，编译器会自动把高级语言的代码像指针那样搞成两块内存来处理。因此一个引用类型的变量也是占用8个字节的内存，跟指针一样，64位CPU。

#### 4、为什么要是使用引用类型？

使用引用可以达到跟指针类似的效果，但：

* 从上面很多的例子可以看出引用比指针的写法更简单、更易读，引用只需要在声明变量的时候用个&，其它阶段都是直接拿变量名用就可以了，而指针在不同的阶段可能要频繁地出现*和&，容易把人绕蒙
* 指针是个很强大的东西，但也容易出现问题，比如指针不用初始化也能使用——即使用空指针、在初始化后还可以修改指向、可以越界访问，而引用则弱化了指针的这些功能，使用起来更加安全