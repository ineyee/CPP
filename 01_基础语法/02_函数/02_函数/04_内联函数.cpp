#include <iostream>
using namespace std;

// 1、内联函数是什么？
// 使用inline修饰的函数就是内联函数
// 比如下面这个函数就是内联函数
//inline int add(int i1, int i2) {
//    return i1 + i2;
//}
// 下面这个函数就不是内联函数
//double add(double d1, double d2) {
//    return d1 + d2;
//}

// 2、内联函数的本质是什么？
// 内联函数在声明和实现阶段跟普通函数没有任何区别，内联函数的本质其实就是在函数调用阶段会直接展开为函数的执行体，而不存在函数调用
// 比如add_04(10, 20);这个函数的调用，本质上会直接替换为10 + 20这么一句代码，而不存在函数调用
// 而add_04(10.0, 20.0);这个函数的调用才存在函数调用
// 这可以通过汇编来验证

// 3、怎么使用内联函数？
// （1）我们只能用inline修饰每一个函数，不能用inline修饰一堆函数
//inline int add(int i1, int i2);
//inline int sub(int i1, int i2) {
//    return i1 - i2;
//}
//inline int mutl(int i1, int i2);
//inline int divi(int i1, int i2) {
//    return i1 / i2;
//}
// （2）如果函数的声明和实现都存在，则用inline修饰的操作可以在声明阶段，也可以在实现阶段，推荐在声明阶段
//inline int mod(int i1, int i2);
//int mod(int i1, int i2) {
//    return i1 % i2;
//}
// （3）注意有些函数即便用inline修饰了，也不一定会被编译器搞成内联函数，比如递归函数，因为递归函数展开为执行体还是原来的函数、无穷无尽

// 4、为什么要使用内联函数？
// （1）经过上面的讲解，我们可能已经发现内联函数跟宏有点像，两者在调用阶段都是替换为具体的实现
// 对比这两者，我们推荐使用内联函数而非宏，因为内联函数在声明阶段和实现阶段起码具备函数的特性，我们编写代码有提示、写错了编译也会报错
// 而宏定义就是硬敲代码了，没提示、编译也不报错
// （2）如果一个函数的执行体很短、并且这个函数调用很频繁，那就可以把这个函数搞成内联函数
// 因为这样可以减少应用程序在运行过程中函数调用的开销、使得运行效率更高，并且因为函数的执行体很短、也不会对可执行文件的体积影响太大
// 但是注意尽量不要把执行体超过10行的函数搞成内联函数，否则可能会明显增大可执行文件的体积

int main() {
    return 0;
}
