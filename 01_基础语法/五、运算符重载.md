## 五、运算符重载

运算符本来是只支持基本数据类型的运算，那如果我们给运算符新增一点功能，比如让加号运算符可以用于对象与对象之间相加、等号运算符可以用于对象与对象之间判断是否相等，或者给左移运算符<<新增打印功能等，这就是运算符重载。

下面我们举个两个点相加的例子：

最原始的做法：

```c++
#include <iostream>
using namespace std;

class Point {
public:
    double m_x;
    double m_y;
    
    Point(int x, int y) {
        m_x = x;
        m_y = y;
    }
};

// 如果我们想做到两个点相加得到第三个点，那可能需要定义一个函数
// 设计函数时参数的注意点：
// 1、传递连续的内存用指针
// 2、函数内部只读而不改动用const修饰
Point point_add(const Point &p1, const Point &p2) {
    return Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);
}

int main() {
    Point p = Point(10, 20);
    Point p1 = Point(30, 40);
    Point p2 = point_add(p, p1);
    cout << p2.m_x << " " << p2.m_y << endl; // 40 60
    
    return 0;
}
```

重载+运算符：

```c++
#include <iostream>
using namespace std;

class Point {
public:
    double m_x;
    double m_y;
    
    Point(int x, int y) {
        m_x = x;
        m_y = y;
    }
};

// 但如果我们能用加法来做的话，代码看起来更直观
// 但是默认情况下+运算符只能对一些基本数据类型做运算，不能对我们自定义的Point类型做运算，但我们又希望能两个点相加，这就要用到运算符重载了————为运算符增加新的功能
// 运算符重载其实就是一个函数，只不过这个函数的函数名固定为：operator运算符
Point operator+(const Point &p1, const Point &p2) {
    return Point(p1.m_x + p2.m_x, p1.m_y + p2.m_y);
}

int main() {
    Point p = Point(10, 20);
    Point p1 = Point(30, 40);
    // Point p2 = p + p1;
    // 这句代码的本质其实就是函数调用：Point p2 = operator+(p, p1);
    Point p2 = p + p1;
//    Point p2 = operator+(p, p1);
    cout << p2.m_x << " " << p2.m_y << endl; // 40 60
    
    return 0;
}
```

搞成成员函数：

```c++
#include <iostream>
using namespace std;

class Point {
public:
    double m_x;
    double m_y;
    
    Point(int x, int y) {
        m_x = x;
        m_y = y;
    }
    
    // 但这个重载只是针对Point类的，最好是放在类内部，没必要放在类外面搞成全局函数，让别人都知道
    // 搞在类内部之后，有以下几个注意点：
    // 1、运算符重载的函数不能是静态成员函数，只能是成员函数
    // 2、既然只能是成员函数，那就意味着外界在调用该函数是必然是p1.operator+(...)，所以这里参数就没必要是两个了，写一个就够了
//    Point operator+(const Point &p1, const Point &p2) {
    Point operator+(const Point &p) {
        return Point(m_x + p.m_x, m_y + p.m_y);
    }
};

int main() {
    Point p = Point(10, 20);
    Point p1 = Point(30, 40);
    // Point p2 = p + p1;
    // 这句代码的本质其实就是函数调用：Point p2 = p.operator+(p1);
    Point p2 = p + p1;
//    Point p2 = operator+(p, p1);
    cout << p2.m_x << " " << p2.m_y << endl; // 40 60
    
    // Point p3 = p + p1 + p2;
    // 这句代码的本质其实就是函数调用：Point p3 = (p.operator+(p1)).operator+(p2);
    Point p3 = p + p1 + p2;
//    Point p3 = (p.operator+(p1)).operator+(p2);
    cout << p3.m_x << " " << p3.m_y << endl; // 80 120
    
    return 0;
}
```

至此还不满意，我们知道“加法运算这个表达式是不应该能被赋值的”，而我们上面的例子中点的加法运算表达式竟然可以被赋值，这是不行的，要处理一下，处理方式也很简单，就是把运算符重载函数的返回值用const修饰即可——即返回值不能被改嘛。

```c++
int a = 10;
int b = 20;
(a + b) = 40; // 编译报错

(p + p1) = p2; // 竟然编译通过
```

```c++
    Point operator+(const Point &p) {
        return Point(m_x + p.m_x, m_y + p.m_y);
    } 

// 改成下面这样

const Point operator+(const Point &p) {
        return Point(m_x + p.m_x, m_y + p.m_y);
    }

(p + p1) = p2; // 编译就不会通过了
```

但带来了新的问题，返回值加了const之后下面搞得下面的代码编译报错了，原因其实也很简单，我们知道p.operator+(p1)调用完毕后会返回一个const Point对象，而const对象又只能调用const成员函数，但是我们的operator+不是const函数，所以还得把operator+函数搞成const函数。

```c++
    Point p3 = p + p1 + p2;
//    Point p3 = (p.operator+(p1)).operator+(p2);
```

最终版：

```c++
const Point operator+(const Point &p) const {
    return Point(m_x + p.m_x, m_y + p.m_y);
}
```